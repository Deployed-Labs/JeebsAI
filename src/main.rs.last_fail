use actix_session::Session;
// Modules are provided by the library crate (`src/lib.rs`).
use jeebs::{auth, cortex, logging, plugins, security, state, updater, utils};

use crate::plugins::{
    Base64Plugin, CalcPlugin, ContactPlugin, ErrorPlugin, HashPlugin, LogicPlugin, MemoryPlugin,
    NewsPlugin, PasswordPlugin, SummaryPlugin, SystemPlugin, TimePlugin, TodoPlugin,
    TranslatePlugin, WeatherPlugin, WebsiteStatusPlugin,
};
use actix_files::Files;
use actix_governor::{Governor, GovernorConfigBuilder, KeyExtractor, SimpleKeyExtractionError};
use actix_session::{storage::CookieSessionStore, SessionMiddleware};
use actix_web::cookie::Key;
use actix_web::dev::{Service, ServiceRequest};
use actix_web::middleware::Logger;
use actix_web::{web, get, App, HttpResponse, HttpServer, Responder};
use futures_util::future::{ready, Either};
use sqlx::sqlite::SqlitePoolOptions;
use sqlx::Row;
use std::collections::HashSet;
use std::sync::Mutex;
use std::sync::{Arc, RwLock};
use sysinfo::System;

use crate::state::AppState;

#[get("/health")]
async fn health_check(data: web::Data<AppState>, session: Session) -> impl Responder {
    let username = match session.get::<String>("username") {
        Ok(Some(u)) => u,
        _ => {
            return HttpResponse::Unauthorized()
                .json(serde_json::json!({"error": "Not logged in"}));
        }
    };

    let user_key = format!("user:{username}");
    if let Ok(Some(row)) = sqlx::query("SELECT value FROM jeebs_store WHERE key = ?")
        .bind(&user_key)
        .fetch_optional(&data.db)
        .await
    {
        let val: Vec<u8> = row.get(0);
        if let Ok(user_json) = serde_json::from_slice::<serde_json::Value>(&val) {
            let role = user_json["role"].as_str().unwrap_or("user");
            if role == "admin" || role == "moderator" {
                return HttpResponse::Ok().json(serde_json::json!({
                    "status": "ok",
                    "timestamp": chrono::Local::now().to_rfc3339()
                }));
            }
        }
    }

    HttpResponse::Forbidden().json(serde_json::json!({"error": "Access denied"}))
}

#[tokio::main]
async fn main() -> std::io::Result<()> {
    let database_url =
        std::env::var("DATABASE_URL").unwrap_or_else(|_| "sqlite:jeebs.db".to_string());
    println!("Connecting to database: {database_url}");
    let db = SqlitePoolOptions::new()
        .connect(&database_url)
        .await
        .expect("Failed to connect to database");

    sqlx::migrate!()
        .run(&db)
        .await;
    cortex::Cortex::seed_knowledge(&db).await;

    // Ensure admin account exists
    auth::ensure_admin_exists(&db).await;
    auth::ensure_user(&db, "1090mb", "ewah", "admin").await;

    // Initialize Logging (Database)
    logging::init(&db).await;

    // Start log cleanup background task
    let log_db_clone = db.clone();
    tokio::spawn(async move {
        // This task will run on startup and then once every 24 hours.
        loop {
            logging::cleanup_old_logs(&log_db_clone).await;
            tokio::time::sleep(tokio::time::Duration::from_secs(24 * 60 * 60)).await;
        }
    });

    // Seed basic knowledge
    cortex::Cortex::seed_knowledge(&db).await;

    // Start GitHub update watcher in background
    tokio::spawn(updater::github_update_watcher());

    // Start Cortex Dreaming (Background Optimization)
    tokio::spawn(cortex::Cortex::dream(db.clone()));

    // Initialize Plugins
    let mut plugins: Vec<Box<dyn crate::plugins::Plugin>> = vec![
        Box::new(TimePlugin),
        Box::new(CalcPlugin),
        Box::new(WeatherPlugin),
        Box::new(NewsPlugin),
        Box::new(MemoryPlugin),
        Box::new(SystemPlugin),
        Box::new(SummaryPlugin),
        Box::new(TranslatePlugin),
        Box::new(PasswordPlugin),
        Box::new(HashPlugin),
        Box::new(Base64Plugin),
        Box::new(crate::security::SecurityPlugin),
        Box::new(LogicPlugin),
        Box::new(ContactPlugin),
        Box::new(WebsiteStatusPlugin),
        Box::new(TodoPlugin),
        Box::new(ErrorPlugin),
    ];
    plugins.extend(crate::plugins::load_dynamic_plugins("plugins"));

    // Load IP Blacklist
    let rows = sqlx::query("SELECT ip FROM ip_blacklist")
        .fetch_all(&db)
        .await
        .expect("Failed to load blacklist");
    let mut ips = HashSet::new();
    for row in rows {
        let ip: String = row.get(0);
        ips.insert(ip);
    }
    let ip_blacklist = Arc::new(RwLock::new(ips));

    // Load IP Whitelist
    let rows = sqlx::query("SELECT ip FROM ip_whitelist")
        .fetch_all(&db)
        .await
        .expect("Failed to load whitelist");
    let mut w_ips = HashSet::new();
    for row in rows {
        let ip: String = row.get(0);
        w_ips.insert(ip);
    }
    let ip_whitelist = Arc::new(RwLock::new(w_ips));

    // System Info
    let sys = System::new_all();

    // Internet connectivity control (default: disabled for security)
    let internet_enabled = Arc::new(RwLock::new(false));

    // Start web server in background
    let state = web::Data::new(AppState {
        db: db.clone(),
        plugins,
        ip_blacklist,
        ip_whitelist,
        sys: Arc::new(Mutex::new(sys)),
        internet_enabled,
    });
    let _secret_key = Key::generate();


		#[derive(Clone)]
		struct WhitelistedKeyExtractor;
		impl KeyExtractor for WhitelistedKeyExtractor {
			type Key = String;
		type KeyExtractionError = SimpleKeyExtractionError<String>;
			fn extract(&self, req: &ServiceRequest) -> Result<Self::Key, Self::KeyExtractionError> {
				let state = req.app_data::<web::Data<AppState>>().unwrap();
				let ip = req.peer_addr().map(|a| a.ip().to_string()).unwrap_or_else(|| "unknown".to_string());
				if state.ip_whitelist.read().unwrap().contains(&ip) {
					return Ok(format!("whitelist:{}", uuid::Uuid::new_v4())); // Unique key per request bypasses rate limit
				}
				Ok(ip)
			}
		}

		let _governor_conf = GovernorConfigBuilder::default()
			.key_extractor(WhitelistedKeyExtractor)
			.requests_per_second(2)
			.burst_size(5)
			.finish()
			.unwrap();
    let port = std::env::var("PORT")
        .unwrap_or_else(|_| "8080".to_string())
        .parse::<u16>()
        .unwrap_or(8080);

    println!("Jeebs is waking up on 0.0.0.0:{}", port);

    HttpServer::new(move || {
        App::new()
            .app_data(web::Data::new(state.clone()))
            .service(web::resource("/login").route(web::post().to(auth::login)))
            .service(web::resource("/login_pgp").route(web::post().to(auth::login_pgp)))
            .service(auth::change_password)
            .service(cortex::admin_train)
            .service(cortex::admin_crawl)
            .service(cortex::search_brain)
            .service(cortex::reindex_brain)
            .service(cortex::visualize_brain)
            .service(cortex::get_logic_graph)
    })
    .bind(("0.0.0.0", port))?
    .run()
    .await
}